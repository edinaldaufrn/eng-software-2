# Tarefa 01 - Git e GitHub com Markdown

* **Nome**: Leonardo Dantas da Silva
* **GitHub**: [leonardodantas4](https://github.com/leonardodantas4)
* **Email**: leonardodds@hotmail.com 

## Projeto Gestor de Laboratório - Gestor Lab

* **Descrição**: O Gestor Lab é um software de gestão de laboratórios.
* **Equipe**: [Breno Alves](https://github.com/brenolves); [Eduardo Henrique](https://github.com/rickEDU); [Jeison Oliveira](https://github.com/jeisonoliver); [Leonardo Dantas](https://github.com/leonardodantas4); [Pedro Augusto](https://github.com/PedroAugustoMD); [Renildo Rabi](https://github.com/Renildo15).
* **Link para o repositório**: https://github.com/Renildo15/Gestor-Lab

### Python

* A linguagem de programação que será utilizada no projeto será **Python**, pois é uma linguagem Open-Source de propósito geral usado bastante em data science, machine learning, desenvolvimento de web, desenvolvimento de aplicativos, automação de scripts, fintechs e mais. A equipe possui uma certa base de Python, já que já programaram pelo menos uma vez com essa linguagem.

### Django

* O framework utilizado no projeto será o **Django**, pois é um framework web full stack open source (código aberto) baseado em Python, gratuito e de alto nível.

### VSCode

* A IDE que será utilizada no projeto será o **VSCode**, pois o mesmo é dedicado à otimização de linhas, fazendo com que os softwares sejam mais leves, eficientes e compatíveis com diferentes plataformas. Ele inclui suporte para depuração, controle de versionamento Git incorporado, realce de sintaxe, complementação inteligente de código, snippets e refatoração de código.

### Tutorial de CRUD em Django

[Link!](https://www.youtube.com/watch?v=SYr4cKavw-0) - Vídeo de como criar um CRUD em Django.

### Branches e pull request

* **Branches**: É uma ramificação do seu projeto. É útil em situações nas quais você deseja adicionar um novo recurso ou corrigir um erro, gerando uma nova ramificação garantindo que o código instável não seja mesclado nos arquivos do projeto principal. Depois de concluir a atualização dos códigos da ramificação, você pode mesclar a ramificação com a principal, geralmente chamada de master.
* **Pull request**: É uma forma colaborativa de compartilhar criação ou mudanças de código no repositório, de forma que facilite ser revisado e/ou discutido entre todos os membros da equipe.

### Versionamento Semântico

O **Versionamento Semântico** nada mais é do que um conjunto de regras e particularidades que mostram como os números das versões do aplicativo foram desenvolvidos. Em outras palavras, a quantidade de mudanças pelas quais o app passou e quais alterações foram compatíveis ou incompatíveis com a versão anterior. O desafio por trás de manter o sistema atualizado para os usuários é assegurar especificações claras sobre o aplicativo, do contrário os números são praticamente inúteis para o gerenciamento correto do software. 

* Especificações do Versionamento Semântico:
1. O aplicativo que usar o versionamento deve ter instruções e padrões de programação de fácil compreensão.
2. A versão normal do app precisa estar no formato inteiro e os números não podem ser negativos. Também não pode haver zeros à esquerda e os valores sempre devem aumentar numericamente. Por exemplo: 1.1 -> 1.2 -> 1.3.
3. Uma vez que um pacote for lançado, o conteúdo do aplicativo não deve ser alterado. Se existir a necessidade de qualquer modificação, o software precisa ser lançado com uma nova versão.
4. A versão de correção deve ser incrementada apenas se mantiver a compatibilidade ao introduzir correção de bugs.
5. Uma versão de pré-lançamento pode ser indicada com uma série de identificadores separados por ponto. Ela indicará que a versão do app é instável e que poderá não satisfazer a todos os requisitos de compatibilidade pretendidos. Exemplos: 1.0.1, 1.0.1.1, 1.0.1.2.

### Conventional Commits

O **Conventional Commits** é uma convenção simples de mensagens de commit, que segue um conjunto de regras e que ajuda os projetos a terem um histórico de commit explícito e bem estruturado. Há vários benefícios em utilizar esse tipo de convenção, como por exemplo, poder automatizar a criação de CHANGELOGs, facilitar a entrada de novos Devs no projeto, assim como poder gerar relatórios e conseguir entender onde está se concentrando as horas do projeto (em refatoração de código, criação de features, mudança de estilos, ambiente de desenvolvimento, entre outros).